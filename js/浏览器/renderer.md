
用户看到页面实际上可以分为两个阶段：页面内容加载完成和页面资源加载完成，分别对应于`DOMContentLoaded`和`Load`。

1. `DOMContentLoaded`事件触发时，仅当DOM加载完成，不包括样式表，图片等
2. `load`事件触发时，页面上所有的DOM，样式表，脚本，图片都已加载完成

都可以被 `document.addEventListener` 监听到

#### GUI线程渲染过程

从图中可以看出，一个渲染引擎大致包括`HTML`解释器、`CSS`解释器、布局和`JavaScript`引擎。

`HTML`解释器：解释`HTML`语言的解释器，本质是将`HTML`文本解释成`DOM`树（文档对象模型）。

`CSS`解释器：解释样式表的解释器，其作用是将`DOM`中的各个元素对象加上样式信息，从而为计算最后结果的布局提供依据。

布局：将`DOM`和`css`样式信息结合起来，计算它们的大小位置等布局信息，形成一个能够表示这所有信息的内部表示模型即渲染树。

这些模块依赖很多其他的基础模块，这其中包括网络，存储，2D/3D图形，音频视频和图片解码器等。实际上，渲染引擎中还应该包括如何使用这些依赖模块的部分，这部分的工作其实并不少，因为需要使用它们来高效的渲染网页。例如，利用2D/3D图形库来实现高性能的网页绘制和网页的3D渲染，这个实现非常非常的复杂。最后，当然，在最下面，依然少不了操作系统的支持，例如线程支持，文件支持等等。

1. 浏览器将获取的`HTML`文档解析成`DOM`树。

2. 处理`CSS`标记，构成层叠样式表模型`CSSOM`(`CSS Object Model`)。

3. 将`DOM`和`CSSOM`合并为渲染树(`rendering tree`)，代表一系列将被渲染的对象。

4. 渲染树的每个元素包含的内容都是计算过的，它被称之为布局`layout`。浏览器使用一种流式处理的方法，只需要一次绘制操作就可以布局所有的元素。

5. 将渲染树的各个节点绘制到屏幕上，这一步被称为绘制`painting`。

需要注意的是，以上五个步骤并不一定一次性顺序完成，比如`DOM`或`CSSOM`被修改时，亦或是哪个过程会重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。而在实际情况中，`JavaScript`和`CSS`的某些操作往往会多次修改`DOM`或者`CSSOM`。

![render-1](../assets/render-1.png)


#### 浏览器渲染网页的具体流程

构建`DOM`树

当浏览器接收到服务器响应来的HTML文档后，会遍历文档节点，生成`DOM`树。
需要注意以下几点：

1. `DOM`树在构建的过程中可能会被`CSS`和`JS`的加载而执行阻塞

2. `display:none`的元素也会在`DOM`树中

3. 注释也会在`DOM`树中

4. `script`标签会在`DOM`树中

无论是`DOM`还是`CSSOM`，都是要经过`Bytes→characters→tokens→nodes→object model`这个过程。

当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点

![render-2](../assets/render-2.png)

#### 构建CSSOM树

浏览器解析`CSS`文件并生成`CSSOM`，每个`CSS`文件都被分析成一个`StyleSheet`对象，每个对象都包含`CSS`规则。`CSS`规则对象包含对应于`CSS`语法的选择器和声明对象以及其他对象

1. `CSS`解析可以与`DOM`解析同时进行。

2. `CSS`解析与`script`的执行互斥 。

3. 在`Webkit`内核中进行了`script`执行优化，只有在`JS`访问`CSS`时才会发生互斥。

#### 重绘与重排

1. 重绘(`repaint`) 重绘是改变不影响元素在网页中的位置的元素样式时，譬如background-color(背景色)， border-color(边框色)， visibility(可见性)，浏览器会根据元素的新属性重新绘制一次(这就是重绘，或者说重新构造样式)，使元素呈现新的外观。重绘不会带来重新布局，所以并不一定伴随重排。

2. 重排(`Reflow`) 渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排当改变影响到文本内容或结构，或者元素位置时，重排或者说重新布局就会发生

    + `DOM`操作（元素添加、删除、修改或者元素顺序的改变）
    + 内容变化，包括表单域内的文本改变
    + `CSS`属性的计算或改变
    + 添加或删除样式表
    + 更改“类”的属性
    + 浏览器窗口的操作（缩放，滚动）
    + 伪类激活（悬停）

"重绘"不一定需要"重排"，比如改变某个网页元素的颜色，就只会触发"重绘"，不会触发"重排"，因为布局没有改变。

但是，"重排"必然导致"重绘"，比如改变一个网页元素的位置，就会同时触发"重排"和"重绘"，因为布局改变了。

优化渲染:

1. 将多次改变样式属性的操作合并成一次操作

2. 将需要多次重排的元素，`position`属性设为`absolute`或`fixed`脱离普通文档流

3. 由于`display`属性为`none`的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排

    如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排

`display:none`:
隐藏元素，不占网页中的任何空间，让这个元素彻底消失（看不见也摸不着）,由于会影响到网页的空间，所以会引起一次重排和重绘。

`visibility:hidden`:
他是把那个层隐藏了，也就是你看不到它的内容但是它内容所占据的空间还是存在的。（看不见但摸得到），该操作不会对页面有影响，所以只会引起一次重绘。

`overflow:hidden`:
让超出的元素隐藏（不占据网页空间），就是在设置该属性的时候他会根据你设置的宽高把多余的那部分剪掉，会引起一次重排和重绘。

https://www.jianshu.com/p/e6252dc9be32